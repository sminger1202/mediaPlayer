package com.baseproject.utils;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.text.SimpleDateFormat;import java.util.regex.Matcher;import java.util.regex.Pattern;import android.content.Context;import android.content.Intent;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.res.Configuration;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.os.StatFs;import android.telephony.TelephonyManager;import android.text.TextUtils;import android.util.Base64;import com.decapi.DecAPI;/** * @Description: TODO 工具类 *  * @author 刘仲男 81595157@qq.com * @version 1.0 * @created time 2012-9-13下午3:31:47 */public final class Util {	// application 上下文	// public static Context mContext;	// 汉字	public static final int CHINESE = 0;	// 数字或字母	public static final int NUMBER_OR_CHARACTER = 1;	// 数字和字母	public static final int NUMBER_CHARACTER = 2;	// 数字、字母、汉字	public static final int MIX = 3;	private Util() {	}	public static final int EXCEPTION = -1;	public static String getBundleValue(Bundle bundle, String label,			String Default, boolean throwException) {		String value = null;		try {			value = bundle.getString(label);		} catch (Exception e) {			if (throwException) {				Logger.e("F.getBundleValue()", e);			} else {				Logger.e("throw Exception:  get String Bundle label " + label						+ " is null");			}		}		if (TextUtils.isEmpty(value)) {			return Default;		}		return value;	}	/**	 * 传入秒, 返回格式化的String	 **/	public static String formatTime(long time) {		String minute = "" + time / 60;		String second = "" + time % 60;		if (minute.length() == 1)			minute = "0" + minute;		if (second.length() == 1)			second = "0" + second;		return minute + "分" + second + "秒";	}//	/**//	 *  判断字符串是否为空//	 *///	public static boolean isNull(String str) {//		return str == null || str.length() == 0;//	}	/** 传入秒, 返回格式化的String */	public static String formatTime(double s) {		try {			long msec = (long) s;			String minutes, seconds;			seconds = "00" + (msec) % 60;			minutes = "" + (msec / 60);			if (minutes.length() == 1)				minutes = "0" + minutes;			seconds = seconds.substring(seconds.length() - 2, seconds.length());			String times = minutes + ":" + seconds;			return times;		} catch (Exception e) {			Logger.e("ERROR formatTime() e=" + e.toString());			return "";		}	}	public static String URLEncoder(String s) {		if (s == null || s.trim().length() == 0)			return "";		try {			s = URLEncoder.encode(s, "UTF-8");		} catch (UnsupportedEncodingException e) {			return "";		} catch (NullPointerException e) {			return "";		}		return s;	}	/** 是否是MD5值 */	public static boolean isMD5(String s) {		if (s != null && s.length() == 32)			return true;		return false;	}	/** 获得MD5串 */	public static String md5(final String s) {		try {			MessageDigest digest = MessageDigest					.getInstance("MD5");			digest.update(s.getBytes());			byte messageDigest[] = digest.digest();			StringBuffer hexString = new StringBuffer();			for (int i = 0; i < messageDigest.length; i++) {				String h = Integer.toHexString(0xFF & messageDigest[i]);				while (h.length() < 2)					h = "0" + h;				hexString.append(h);			}			return hexString.toString();		} catch (NoSuchAlgorithmException e) {			Logger.e("Util.md5()", e);			return "";		}	}	/**	 * @return 图片地址的特征字串	 */	public static String getPosterImgUrlTrait(String imgUrl) {		String s;		try {			s = URLEncoder.encode(imgUrl.replace("*", ""), "UTF-8");		} catch (UnsupportedEncodingException e) {			Logger.e("Util#getPosterImgUrlTrait()", e);			s = "";		}		return s;	}	private final static String LINE_SEPARATOR = System			.getProperty("line.separator");	public static String convertStreamToString(InputStream is) {		/*		 * To convert the InputStream to String we use the		 * BufferedReader.readLine() method. We iterate until the BufferedReader		 * return null which means there's no more data to read. Each line will		 * appended to a StringBuilder and returned as String.		 */		final BufferedReader reader = new BufferedReader(new InputStreamReader(				is));		final StringBuilder sb = new StringBuilder();		String line = null;		try {			while ((line = reader.readLine()) != null) {				sb.append(line);				sb.append(LINE_SEPARATOR);			}		} catch (IOException e) {		} finally {			try {				is.close();			} catch (IOException e) {			}		}		return sb.toString();	}	public static void deleteFile(final File file) {		if (file == null)			return;		if (file.exists()) { // 判断文件是否存在			if (file.isFile()) { // 判断是否是文件				file.delete(); // delete()方法 你应该知道 是删除的意思;				return;			} else if (file.isDirectory()) { // 否则如果它是一个目录				File files[] = file.listFiles(); // 声明目录下所有的文件 files[];				if (files != null) {					for (int i = 0; i < files.length; i++) { // 遍历目录下所有的文件						deleteFile(files[i]); // 把每个文件												// 用这个方法进行迭代//(错了,这里叫递归,刘仲男注)					}				}			}			file.delete();		}	}	/**	 * TODO 判断网络状态是否可用	 * 	 * @return true: 网络可用 ; false: 网络不可用	 */	public static boolean hasInternet() {		ConnectivityManager m = (ConnectivityManager) Profile.mContext				.getSystemService(Context.CONNECTIVITY_SERVICE);		if (m == null) {			Logger.d("NetWorkState", "Unavailabel");			return false;		} else {			NetworkInfo[] info = m.getAllNetworkInfo();			if (info != null) {				for (int i = 0; i < info.length; i++) {					if (info[i].getState() == NetworkInfo.State.CONNECTED) {						Logger.d("NetWorkState", "Availabel");						return true;					}				}			}		}		return false;	}	/**	 * @return 是否是wifi网络	 */	public static boolean isWifi() {		ConnectivityManager m = (ConnectivityManager) Profile.mContext				.getSystemService(Context.CONNECTIVITY_SERVICE);		NetworkInfo n = m.getActiveNetworkInfo();		if (n != null && n.getType() == ConnectivityManager.TYPE_WIFI)			return true;		return false;	}	/**	 * @return 网络类型	 */	public static int getNetworkType() {		ConnectivityManager m = (ConnectivityManager) Profile.mContext				.getSystemService(Context.CONNECTIVITY_SERVICE);		NetworkInfo info = m.getActiveNetworkInfo();		if (info != null) {			if (info.getType() == ConnectivityManager.TYPE_WIFI) {				return NetworkType.WIFI;			} else if (info.getType() == ConnectivityManager.TYPE_MOBILE) {				switch (info.getSubtype()) {				case TelephonyManager.NETWORK_TYPE_1xRTT:					return NetworkType.LxRTT;				case TelephonyManager.NETWORK_TYPE_CDMA:					return NetworkType.CDMA;				case TelephonyManager.NETWORK_TYPE_EDGE:					return NetworkType.EDGE;				case TelephonyManager.NETWORK_TYPE_EHRPD:					return NetworkType.EHRPD;				case TelephonyManager.NETWORK_TYPE_EVDO_0:					return NetworkType.EVDO_0;				case TelephonyManager.NETWORK_TYPE_EVDO_A:					return NetworkType.EVDO_A;				case TelephonyManager.NETWORK_TYPE_EVDO_B:					return NetworkType.EVDO_B;				case TelephonyManager.NETWORK_TYPE_GPRS:					return NetworkType.GPRS;				case TelephonyManager.NETWORK_TYPE_HSDPA:					return NetworkType.HSDPA;				case TelephonyManager.NETWORK_TYPE_HSPA:					return NetworkType.HSPA;				case TelephonyManager.NETWORK_TYPE_HSPAP:					return NetworkType.HSPAPlus;				case TelephonyManager.NETWORK_TYPE_HSUPA:					return NetworkType.HSUPA;				case TelephonyManager.NETWORK_TYPE_IDEN:					return NetworkType.IDEN;				case TelephonyManager.NETWORK_TYPE_LTE:					return NetworkType.LTE;				case TelephonyManager.NETWORK_TYPE_UMTS:					return NetworkType.UMTS;				}			}		}		return NetworkType.UNKNOWN;	}	// public static String formatDuration(int second) {	// int hh = 0;	// int mm = 0;	// if (second >= 3600)	// hh = second / 3600;	// if ((second - 3600 * hh) >= 60)	// mm = (second - 3600 * hh) / 60;	// if (hh == 0)	// return String.format("%1$02d:%2$02d", mm, second - 3600 * hh - 60	// * mm);	// else	// return String.format("%1$02d:%2$02d:%3$02d", hh, mm, second - 3600	// * hh - 60 * mm);	// }	// public static boolean checkUserNickName(String line) {	// Pattern p = Pattern.compile("[^0-9a-zA-Z_\u4e00-\u9fa5]+");	// Matcher m = p.matcher(line);	// return !m.find();	// }	// public static boolean checkPassword(String line) {	// Pattern p = Pattern.compile("[^0-9a-zA-Z]+");	// Matcher m = p.matcher(line);	// return !m.find();	// }	/**	 * 验证码， 可以输入字母大小写都可以，还有数字	 * 	 * @param line	 *            输入	 * @param length	 *            长度	 * @return	 */	public static boolean checkVerificationCode(String line, int length) {		if (line.contains(" ")) {			return false;		}		Pattern p = Pattern.compile("[^0-9a-zA-Z]+");		Matcher m = p.matcher(line);		return !m.find() && line.length() == length;	}	// public static int getEnNZhMixStringLength(String str) {	// return str.length() + getChineseCharCount(str);	// }	/** Returns 是否有SD卡 */	public static boolean hasSDCard() {		if (Environment.MEDIA_MOUNTED.equals(Environment				.getExternalStorageState()))			return true;		return false;	}	// public static String readStream(InputStream inputStream) throws Exception	// {	// ByteArrayOutputStream outStream = new ByteArrayOutputStream();	// byte[] buffer = new byte[1024];	// int len = 0;	// while ((len = inputStream.read(buffer)) != -1) {	// outStream.write(buffer, 0, len);	// }	// outStream.close();	// inputStream.close();	// return new String(outStream.toByteArray());	// }	public static String join(Object... objs) {		if (objs == null)			return null;		StringBuffer result = new StringBuffer();		int i = 0;		for (Object obj : objs) {			result.append(obj + "");			if (i != objs.length - 1)				result.append(",");			i++;		}		return result.toString();	}	/** int型的这个不能省略,因为int转字符串的时候有问题 */	public static String join(int[] numbers) {		String result = "";		int i = 0;		for (int num : numbers) {			result += num;			if (i != numbers.length - 1)				result += ",";			i++;		}		return result;	}	/** long型的这个不能省略,因为long转字符串的时候有问题 */	public static String join(long[] numbers) {		String result = "";		int i = 0;		for (long num : numbers) {			result += num;			if (i != numbers.length - 1)				result += ",";			i++;		}		return result;	}	public static int[] string2int(String[] numbers) {		int[] nums = new int[numbers.length];		int i = 0;		try {			for (String num : numbers) {				nums[i] = Integer.parseInt(num);				i++;			}		} catch (NumberFormatException e) {			// TODO Auto-generated catch block			return nums;		}		return nums;	}	public static long[] string2long(String[] numbers) {		long[] nums = new long[numbers.length];		int i = 0;		try {			for (String num : numbers) {				nums[i] = Long.parseLong(num);				i++;			}		} catch (NumberFormatException e) {			// TODO Auto-generated catch block			return nums;		}		return nums;	}	private static final float scale = Profile.mContext.getResources()			.getDisplayMetrics().density;	private static final float scaledDensity = Profile.mContext.getResources()			.getDisplayMetrics().scaledDensity;	public static int dip2px(float dipValue) {		return (int) (dipValue * scale + 0.5f);	}	public static int px2dip(float pxValue) {		return (int) (pxValue / scale + 0.5f);	}	public static float sp2px(float spValue, int type) {		switch (type) {		case CHINESE:			return spValue * scaledDensity;		case NUMBER_OR_CHARACTER:			return spValue * scaledDensity * 10.0f / 18.0f;		default:			return spValue * scaledDensity;		}	}	public static boolean isNumber(String str) {		// return str.matches("^[-+]?(([0-9]+)([.]([0-9]+))?)$");		return str.matches("[\\d]+[.]?[\\d]+");	}	public static int judgeStringType(String input) {		String chineseRegex = "^[\u4e00-\u9fa5]*$";		String character = "^[A-Za-z]+$";		String numberRegex = "^[0-9]+$";		String numberAndChar = "[0-9]+[A-Za-z]+";		String numberAndChineseRegex = "[0-9]+[\u4e00-\u9fa5]+";		String charAndChineseRegex = "[A-Za-z]+[\u4e00-\u9fa5]+";		String all = "[0-9]+[\u4e00-\u9fa5]+[A-Za-z]+";		if (input.matches(chineseRegex)) {			return CHINESE;		} else if (input.matches(charAndChineseRegex)) {			return NUMBER_CHARACTER;		} else if (input.matches(character)) {			return NUMBER_OR_CHARACTER;		} else if (input.matches(numberRegex)) {			return NUMBER_OR_CHARACTER;		} else if (input.matches(numberAndChineseRegex)) {			return NUMBER_CHARACTER;		} else if (input.matches(all)) {			return MIX;		} else if (input.matches(numberAndChar)) {			return NUMBER_OR_CHARACTER;		} else			return CHINESE;	}	public static int numbersCount(String input) {		String numberRegex = "[0-9]";		int count = 0;		for (int i = 0; i < input.length(); i++) {			if ((input.charAt(i) + "").matches(numberRegex)) {				count++;			}		}		return count;	}	public static int ChineseCount(String input) {		String chineseRegex = "[\u4e00-\u9fa5]";		int count = 0;		for (int i = 0; i < input.length(); i++) {			if ((input.charAt(i) + "").matches(chineseRegex)) {				count++;			}		}		return count;	}	// /** 显示提示框 */	// public static void showToast(Object msgString) {	// if (msgString == null || msgString.equals(""))	// return;	// Message msg = new Message();	// Bundle data = new Bundle();	// data.putString("ToastMsg", msgString + "");	// msg.what = 0;	// msg.setData(data);	// MsgHandler msgHandler = new MsgHandler(Looper.getMainLooper());	// msgHandler.sendMessage(msg);	// }	//	// public static void showTips(int stringId) {	// showTips(mContext.getString(stringId), -1l);	// }	//	// public static void showTips(String tipsString) {	// showTips(tipsString, -1L);	// }	//	// public static void showTips(int stringId, long threshold) {	// showTips(mContext.getString(stringId), -1l);	// }	// /** threshold the downloadtask create time */	// public static void showTips(String tipsString, long threshold) {	// Logger.d("Youku.showTips():" + tipsString);	// Message msg = Message.obtain();	// msg.what = 1;	// Bundle bundle = new Bundle();	// bundle.putString("tipsString", tipsString);	// bundle.putLong("threshold", threshold);	// msg.setData(bundle);	// MsgHandler msgHandler = new MsgHandler(Looper.getMainLooper());	// msgHandler.sendMessage(msg);	// }	// private static class MsgHandler extends Handler {	// public MsgHandler(Looper looper) {	// super(looper);	// }	//	// @Override	// public void handleMessage(Message msg) {	// // TODO Auto-generated method stub	// switch (msg.what) {	// case 0:	// Toast.makeText(mContext,	// msg.getData().getString("ToastMsg"), Toast.LENGTH_LONG)	// .show();	// break;	// case 1:	// handleShowTipsEvents(msg);	// break;	// }	// super.handleMessage(msg);	// }	private long previousToastShow;	private String previousToastString = "";	//	// private void handleShowTipsEvents(Message msg) {	// long thisTime = System.currentTimeMillis();	// String thisTimeMsg = msg.getData().getString("tipsString");	// long threshold = msg.getData().getLong("threshold", -1L);	// String temp = previousToastString;	// previousToastString = thisTimeMsg;	// long tempTime = previousToastShow;	// previousToastShow = thisTime;	// if (thisTimeMsg == null || thisTime - tempTime <= 3500	// && thisTimeMsg.equalsIgnoreCase(temp)) {	// previousToastString = temp;	// previousToastShow = tempTime;	// return;	// }	// Toast t = new Toast(mContext);	// t.setGravity(Gravity.TOP | Gravity.FILL_HORIZONTAL, 0, 0);	// int duration = msg.getData().getInt("tipsDuration", 0);	// if (threshold > 0L) {	// t.setDuration(Toast.LENGTH_SHORT);	// } else if (duration == 0) {	// t.setDuration(Toast.LENGTH_LONG);	// } else {	// t.setDuration(duration);	// }	// LayoutInflater mInflater = LayoutInflater.from(mContext);	// View v = mInflater.inflate(R.layout.youku_toast, null);	// v.setMinimumHeight(dip2px(mContext.getResources()	// .getDimension(R.dimen.homepage_title_height)));	// TextView text = (TextView) v.findViewById(R.id.tips_text);	// text.setText(thisTimeMsg);	// t.setView(v);	// t.show();	// previousToastShow = thisTime;	// }	// }	/**	 * TODO Return 是否是横屏	 * */	public static Boolean isLandscape(Context c) {		if (c.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {			return true;		}		return false;	}	/**	 * 跳转到浏览器	 */	public static void goBrowser(Context context, String url) {		Intent i = new Intent(Intent.ACTION_VIEW);		i.setData(Uri.parse(url));		context.startActivity(i);	}	/**	 * 转换文件大小	 * 	 * @param size	 *            单位为kb	 * @return	 */	public static String formatSize(float size) {		long kb = 1024;		long mb = (kb * 1024);		long gb = (mb * 1024);		if (size < kb) {			return String.format("%dB", (int) size);		} else if (size < mb) {			return String.format("%.1fK", size / kb); // 保留两位小数		} else if (size < gb) {			return String.format("%.1fM", size / mb);		} else {			return String.format("%.1fG", size / gb);		}	}	/**	 * TODO Returns SD卡信息	 * 	 * @return null为无SD卡;long[0]总大小;long[1]可用大小;(单位B)	 */	public static long[] getSDCardInfo() {		if (Environment.MEDIA_MOUNTED.equals(Environment				.getExternalStorageState())) {			long[] sdCardInfo = new long[2];			File sdcardDir = Environment.getExternalStorageDirectory();			StatFs sf = new StatFs(sdcardDir.getAbsolutePath());			long bSize = sf.getBlockSize();			long bCount = sf.getBlockCount();			long availBlocks = sf.getAvailableBlocks();			sdCardInfo[0] = bSize * bCount;// 总大小			sdCardInfo[1] = bSize * availBlocks;// 可用大小			return sdCardInfo;		}		return null;	}	/**	 * TODO Returns 优酷视频占有空间大小	 */	public static long getSdcardYoukuSpace() {		File file = new File(Environment.getExternalStorageDirectory()				.getAbsolutePath() + "/youku");		if (!file.exists())			file.mkdirs();		return getFileSize(file);	}	/**	 * TODO Returns 其他程序占有空间大小	 */	public static long getSdcardOtherSpace() {		StatFs statFs = new StatFs(Environment.getExternalStorageDirectory()				.getAbsolutePath());		long nTotalBlocks = statFs.getBlockCount();		long nAvailaBlock = statFs.getAvailableBlocks();		long nBlocSize = statFs.getBlockSize();		long nSDTotalSize = nTotalBlocks * nBlocSize;		long nSDFreeSize = nAvailaBlock * nBlocSize;		return nSDTotalSize - nSDFreeSize - getSdcardYoukuSpace();	}	/**	 * TODO Returns 优酷视频所占空间比例n%	 */	public static int getYoukuProgrss() {		StatFs statFs = new StatFs(Environment.getExternalStorageDirectory()				.getAbsolutePath());		long nTotalBlocks = statFs.getBlockCount();		// long nAvailaBlock = statFs.getAvailableBlocks();		long nBlocSize = statFs.getBlockSize();		long nSDTotalSize = nTotalBlocks * nBlocSize;		// long nSDFreeSize = nAvailaBlock * nBlocSize;		if (nSDTotalSize == 0) {			return 0;		}		return (int) ((100 * getSdcardYoukuSpace()) / nSDTotalSize);	}	/**	 * TODO Returns 其他程序所占空间比例n%	 */	public static int getOtherProgrss() {		StatFs statFs = new StatFs(Environment.getExternalStorageDirectory()				.getAbsolutePath());		long nTotalBlocks = statFs.getBlockCount();		long nAvailaBlock = statFs.getAvailableBlocks();		long nBlocSize = statFs.getBlockSize();		long nSDTotalSize = nTotalBlocks * nBlocSize;		if (nSDTotalSize == 0) {			return 0;		}		long nSDFreeSize = nAvailaBlock * nBlocSize;		long size = nSDTotalSize - nSDFreeSize - getSdcardYoukuSpace();		return (int) ((100 * size) / nSDTotalSize);	}	/**	 * TODO 递归取得文件夹大小	 */	private static long getFileSize(File f) {		long size = 0;		if (f.isDirectory()) {			File flist[] = f.listFiles();			for (int i = 0; i < flist.length; i++) {				if (flist[i].isDirectory()) {					size = size + getFileSize(flist[i]);				} else {					size = size + flist[i].length();				}			}		} else {			size = size + f.length();		}		return size;	}	/**	 * 上次意图退出时间	 */	public static long LAST_EXIT_INTENT_TIME;	/**	 * 	 * @return 是否确认退出App	 */	public static final boolean isConfirmedExit() {		final long currentTime = System.currentTimeMillis();		if (currentTime - LAST_EXIT_INTENT_TIME < 3000) {			return true;		} else {			LAST_EXIT_INTENT_TIME = currentTime;			// showTips("再按一次将退出优酷");			return false;		}	}	/**	 * 清空缓存文件目录	 * 	 * @param dir	 * @return	 */	public static final int clearCacheFolder(final File dir) {		int deletedFiles = 0;		if (dir != null && dir.isDirectory()) {			try {				for (File child : dir.listFiles()) {					// first delete subdirectories recursively					if (child.isDirectory()) {						deletedFiles += clearCacheFolder(child);					}					// then delete the files and subdirectories in this dir					// only empty directories can be deleted, so subdirs have					// been done first					if (child.delete()) {						deletedFiles++;					}				}			} catch (Exception e) {				Logger.e("Util#clearCacheFolder()", e);			}		}		return deletedFiles;	}	/**	 * 清空应用中的缓存	 * 	 * @param context	 */	public static void clearCache(final Context context) {		clearCacheFolder(context.getCacheDir());		if (Environment.getExternalStorageState().equals(				Environment.MEDIA_MOUNTED)) {			clearCacheFolder(context.getExternalCacheDir());		}	}	/*	 * MD5加密	 */	public static String getMD5Str(String str) {		MessageDigest messageDigest = null;		try {			messageDigest = MessageDigest.getInstance("MD5");			messageDigest.reset();			messageDigest.update(str.getBytes("UTF-8"));		} catch (NoSuchAlgorithmException e) {			Logger.e("F.getMD5Str()", e);		} catch (UnsupportedEncodingException e) {			Logger.e("F.getMD5Str()", e);		}		byte[] byteArray = messageDigest.digest();		StringBuffer md5StrBuff = new StringBuffer();		for (int i = 0; i < byteArray.length; i++) {			if (Integer.toHexString(0xFF & byteArray[i]).length() == 1)				md5StrBuff.append("0").append(						Integer.toHexString(0xFF & byteArray[i]));			else				md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));		}		// 16位加密，从第9位到25位		return md5StrBuff.substring(8, 24).toString().toUpperCase();	}	public static String getTime() {		SimpleDateFormat sDateFormat = new SimpleDateFormat(				"yyyy-MM-dd hh:mm:ss");		String date = sDateFormat.format(new java.util.Date());		date = date.replace("-", "");		date = date.replace("-", "");		date = date.replace(":", "");		date = date.replace(":", "");		date = date.replace(" ", "");		date = date.substring(2);		date += "000";		return date;	}	public static boolean isFinalUrl(String url) {		if (TextUtils.isEmpty(url))			return false;		url = url.toLowerCase().trim();		if (url.endsWith(".3gp") || url.endsWith(".mp4")				|| url.endsWith(".3gphd") || url.endsWith(".flv")				|| url.endsWith(".3gp") || url.endsWith(".m3u8"))			return true;		return false;	}	// 时间转换 00:23:13转换为 3453453(s)	// 修改105：09格式	public static int getSecond(String T) {		if (-1 == T.indexOf(":"))			return Integer.parseInt("T");		String time = new String(T);		time = ":::" + time;		int lastIndex = time.lastIndexOf(":");		String StrSecond = time.substring(lastIndex + 1);		time = time.substring(0, lastIndex);		lastIndex = time.lastIndexOf(":");		String StrMinutes = time.substring(lastIndex + 1);		time = time.substring(0, lastIndex);		lastIndex = time.lastIndexOf(":");		String StrHours = time.substring(lastIndex + 1);		time = null;		// F.out("StrSecond=" + StrSecond);		// F.out("StrMinutes=" + StrMinutes);		// F.out("StrHours=" + StrHours);		int second = 0;		try {			second += Integer.parseInt(StrSecond);		} catch (Exception e) {			Logger.e("F.getSecond()", e);		}		// F.out("second=" + second);		try {			second += (Integer.parseInt(StrMinutes)) * 60;		} catch (Exception e) {			Logger.e("F.getSecond()", e);		}		// F.out("second=" + second);		try {			second += (Integer.parseInt(StrHours)) * 3600;		} catch (Exception e) {			Logger.e("F.getSecond()", e);		}		// F.out("second=" + second);		return second;	}		/** 一个pid,对应一个secret */	public static String SECRET;	/** 客户端传递来的时间戳 */	public static Long TIME_STAMP;		//用于服务器参数校验	public static String getSecureRequestText(String path) {		if (TextUtils.isEmpty(SECRET) || !isTimeStampValid()) {			return "";		}		String timeStampText = getTimeStampText();		String _t_Data = "&_t_=" + timeStampText;		String _s_Data = getTokenRequestText(timeStampText, path);		return _t_Data + _s_Data;	}		private static String getTimeStampText() {		final long timeStamp = System.currentTimeMillis() / 1000 + TIME_STAMP;		return String.valueOf(timeStamp);	}	private static String getTokenRequestText(String timeStampText, String path) {		String tokenString = "GET" + ":" + path + ":" + timeStampText + ":"				+ SECRET;		String md5Token = Util.md5(tokenString);		return "&_s_=" + md5Token;	}	public static boolean isTimeStampValid() {		return TIME_STAMP == null ? false : true;	}	static char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',			'9', 'a', 'b', 'c', 'd', 'e', 'f' };	public static String byteToHexString(byte[] tmp) {		String s;		// 用字节表示就是 16 个字节		char str[] = new char[16 * 2]; // 每个字节用 16 进制表示的话，使用两个字符，		// 所以表示成 16 进制需要 32 个字符		int k = 0; // 表示转换结果中对应的字符位置		for (int i = 0; i < 16; i++) { // 从第一个字节开始，对 MD5 的每一个字节			// 转换成 16 进制字符的转换			byte byte0 = tmp[i]; // 取第 i 个字节			str[k++] = hexDigits[byte0 >>> 4 & 0xf]; // 取字节中高 4 位的数字转换,			// >>> 为逻辑右移，将符号位一起右移			str[k++] = hexDigits[byte0 & 0xf]; // 取字节中低 4 位的数字转换		}		s = new String(str); // 换后的结果转换为字符串		return s;	}		public static String getEncreptUrl(String url, String fieldId,			String token, String oip, String sid, InputStream is, String did) {		return url				+ "&oip="				+ oip				+ "&sid="				+ sid				+ "&token="				+ token				+ "&did="				+ did				+ "&ev=1&ctype=20&ep="				+ DecAPI.getEncreyptStringInSingleThread(is, sid + "_"						+ fieldId + "_" + token, ENCRYPT_TYPE.YOUKU.ordinal());	}	/**	 * 土豆的url会自己拼接token	 * 	 * @param url	 * @param fieldId	 * @param token	 * @param oip	 * @param sid	 * @param is	 * @return	 */	public static String getEncreptUrl(String url, String fieldId,			String token, String oip, String sid, InputStream is) {		return url				+ (url.contains("pid=") ? "" : "&pid="+Profile.getPid())				+ "&ep="				+ DecAPI.getEncreyptStringInSingleThread(is, sid + "_"						+ fieldId + "_" + token, ENCRYPT_TYPE.TUDOU.ordinal());	}		/**	 * 直播防盗链	 */	public static String getHLSEncreptUrl(String url, String channel,			String token, String oip, String sid, String bps, int retry_count,			InputStream is, ENCRYPT_TYPE type) {		String auth_string = md5(channel + token + retry_count + bps + sid)				.substring(0, 6);		String ep = DecAPI.getEncreyptStringInSingleThread(is, channel + "-"				+ sid + "-" + token + "-" + auth_string + "-" + bps + "-"				+ retry_count, type.ordinal());		return url + "&ep=" + ep;	}    /**     * 获取当前版本名称     *     * @param context     * @return     */    public static String getVersionName(Context context) {        if (context == null) return "";        PackageInfo pkg = null;        try {            pkg = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);        } catch (PackageManager.NameNotFoundException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return (pkg == null) ? null : pkg.versionName;    }	/**	 * flag的值，0：优酷客户端；1：土豆客户端；2：优酷直播；3：土豆直播	 */	public enum ENCRYPT_TYPE {		YOUKU, TUDOU, YOUKU_LIVE, TUDOU_LIVE	}	public static int computeSignature(String str) {		int i = str.length();		int k = 0;		for (int l = 0; l < str.length() - 2; ++l) {			i = 43 * i + str.toCharArray()[(k++)];		}		return i;	}}