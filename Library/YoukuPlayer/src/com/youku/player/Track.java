package com.youku.player;import android.content.Context;import android.content.Intent;import android.os.SystemClock;import android.text.TextUtils;import com.baseproject.utils.Logger;import com.baseproject.utils.Util;import com.youku.analytics.AnalyticsAgent;import com.youku.analytics.data.PlayActionData;import com.youku.player.base.Plantform;import com.youku.player.config.MediaPlayerConfiguration;import com.youku.player.goplay.AdvInfo;import com.youku.player.goplay.Profile;import com.youku.player.goplay.StaticsUtil;import com.youku.player.goplay.VideoAdvInfo;import com.youku.player.module.PlayVideoInfo;import com.youku.player.module.VideoUrlInfo;import com.youku.player.module.VideoUrlInfo.Source;import com.youku.player.p2p.P2pManager;import com.youku.player.plugin.MediaPlayerDelegate;import com.youku.player.service.DisposableHttpTask;import com.youku.player.util.AdUtil;import com.youku.player.util.AnalyticsWrapper;import com.youku.player.util.DetailUtil;import com.youku.player.util.PlayCode;import com.youku.player.util.PlayerUtil;import com.youku.player.util.SessionUnitil;import com.youku.player.util.URLContainer;import com.youku.statistics.IRVideoWrapper;import com.youku.statistics.PlayerStatistics;import com.youku.statistics.StatisticsTask;import com.youku.uplayer.MPPErrorCode;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.util.HashMap;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;public class Track {	/** 可以埋第一次缓冲开始点 */	public static boolean trackLoadingToPlayStart = false;	/** 第一次缓冲开始点 */	private static long loadingToPlayStartTime;	/** 阶段性开始播放时间点 */	private static long playStartedTime = 0;	/** 第一次缓冲时长 */	private static long beforeDuration;	/** 阶段性播放状态 播放中 */	private static boolean stageStarted = false;	/** 当前视频用户观看总时长 （去掉暂停时间） */	private static long playTime = 0;	/** 视频宽度 */	public static int width;	/** 视频高度 */	public static int height;	/** 播放完整性 */	private static boolean isCompleted = false;	/** 是否因网络情况 */	private static boolean trackPlayLoading = false;	/** 视频缓冲时系统时间 */	private static long playLoadingStartTime = 0;	/** 视频缓冲时视频进度 */	private static long playLoadingPosition = 0;	/** 视频缓冲记录 */	private static String playLoadingEvents = "";	/** 视频缓冲时本地时间，用|分隔 */	private static String playLoadingStartLocalTime = "";	/** 可以埋高清标清切换结束点 */	private static boolean trackChangeVideoQualtiy;	/** 高清标清切换开始点 */	private static long changeVideoQualityStartTime;	/** 播放中高清到标清的转换次数，type=end时，必选参数 */	private static int videoQualityToSDTimes = 0;	/** 播放中高清到标清的加载总时长（单位：ms，浮点数，保留2位小数），type=end时，必选参数 */	private static long videoQualityToSDLoadingTime = 0;	/** 播放中标清到高清的转换次数，type=end时，必选参数 */	private static int videoQualityToHDTimes = 0;	/** 播放中标清到高清的加载总时长（单位：ms，浮点数，保留2位小数），type=end时，必选参数 */	private static long videoQualityToHDLoadingTime = 0;	/** 播放中到超清清的转换次数，type=end时，必选参数 */	private static int videoQualityToHD2Times = 0;	/** 播放中到超清清的加载总时长（单位：ms，浮点数，保留2位小数），type=end时，必选参数 */	private static long videoQualityToHD2LoadingTime = 0;	/** 正片开始播放 */	public static boolean isRealVideoStarted = false;	public static boolean mIsChangingLanguage = false;	private static boolean mIsPlayStarted = false;	/** 广告播放开始时间（单位：ms） */	private static long mAdStartTime = 0;	/** 广告结束时间（单位：ms） */	private static long mAdEndTime = 0;	private static long mADBeforeDuration = 0;	private static long mADDuration = 0;    /** 广告播放延时（单位：ms） */    private static String mAdDelays = "";    private static int mAdCountRemain = 0;    private static int mAdCountTotal = 0;    /** 广告url请求时间（单位：ms） */    private static long mAdReqStartTimeStamp = 0;    private static String mAdReqTimes = "";    private static String mAdRsReqTimes = "";    private static int mAdLevel1Error = 0;    private static int mAdLevel2Error = 0;    /** 广告当前贴开始播放并且未结束 */    private static boolean mIsAdStarted = false;	/** 判断是否playRequest()被调用，部分情况点击重播会直接play(), 此标志位仅限play()用 */	private static boolean misRequestCalled = false;	/** 暂时先设置 max loading time为3分钟， 超过这个值将认为不正常，将不传给服务器。 */	private static final long MAX_LOADINGTIME = 3 * 60 * 1000;    private static final String DEFAULT_PLAY_ERROR = "0";    private static final String DEFAULT_AD_DELAY = "-1";    private static final String DEFAULT_AD_REQUIRE_TIME = "-1";    private static final String DEFAULT_AD_RS_REQUIRE_TIME = "-1";	/**	  获取到广告的时间点 */	private static long mGetAdvTime = 0;	/**  获取广告耗费的时间*/	private static long mGetAdvDuration = 0;	/**  获取播放地址耗费的时间*/	private static long mGetPlayListDuration = 0;	/** 当前播放的分片地址*/	private static String mCurrentPlaySlice = "";	private static String mCurrentPlaySliceDetail = "";	/** 播放的分片集合*/	private static LinkedHashMap<String, String> mVideoSlices = new LinkedHashMap<String, String>();	private static LinkedHashMap<String, SliceData> mVideoSlicesDetail = new LinkedHashMap<String, SliceData>();    /** 分片播放时长*/	private static long mSlicePlayTime;	private static boolean isAdChanged = true;	private static boolean isChangeQualityError;		private static int twentyInterval = 20;	private static int heartBeatCount = 1;//心跳次数		/**	 * 是否使用p2p播放，如果中间切换成cdn播放也算p2p	 */	private static boolean usingP2P;    // 正片资源请求时间    private static int mVideoConnectDelayTime;    // 一级错误码    private static int mPlayErrorLevel1;    // 二级错误码    private static int mPlayErrorLevel2;    private static int mSeekCount;    private static String mSeekDuration = "";    private static long mSeekStartTime = 0;    // 统计home返回后的播放错误	private static boolean mVVEndError;	private static boolean mOnPaused;	private static boolean mPlayerStarted;	private static boolean mAdBackError;	// 计算beforeduration时的广告类型	private static TrackAdType mBeforeDurationAdType = TrackAdType.EMPTY;	// 正片广告请求错误	private static String mAdReqError;	private static String mVideoReqError;	// 出错时播放进度	private static int mErrorPoint = -1;	private static String TAG = LogTag.TAG_PREFIX + Track.class.getSimpleName();	private static int mOpenEnhanceTimes = 0; // 开启增强开关的次数	private static int mOpenEnhanceTimesAuto = 0; // 开启增强开关的次数(默认开启)	private static int mCloseEnhanceTimes = 0; // 关闭增强开关的次数	private static int mVideo302Delay; // 正片302跳转，只记首片	private static int mAd302Delay = -1; // 广告302跳转，只记首片	private static boolean isFirstVV;	private static String mAutoPlay = "";	/** 初始化埋点数据 */	public static void init() {		trackLoadingToPlayStart = false;		// trackLoadingToPlayEnd = true;		// stageStarted = false;		// trackPlayEnd = false;		loadingToPlayStartTime = 0;		playStartedTime = 0;		// loadingToPlayEndTime = 0;		isCompleted = false;		trackPlayLoading = false;		playLoadingStartTime = 0;		playLoadingPosition = 0;		// isTrackPlayLoading = false;		playLoadingEvents = "";		playLoadingStartLocalTime = "";		beforeDuration = 0;		stageStarted = false;		videoQualityToSDTimes = 0;		videoQualityToHDTimes = 0;		videoQualityToHD2Times = 0;		videoQualityToSDLoadingTime = 0;		videoQualityToHDLoadingTime = 0;		videoQualityToHD2LoadingTime = 0;		trackChangeVideoQualtiy = false;		changeVideoQualityStartTime = 0;		smoothChangeVideoQualityStartTime = 0;		mSmoothSwitchDetails = "";		isRealVideoStarted = false;		mAdStartTime = 0;		mAdEndTime = 0;		mADBeforeDuration = 0;		mADDuration = 0;		mGetAdvTime = 0;		mGetPlayListDuration = 0;		mGetAdvDuration = 0;		mVideoSlices.clear();		mVideoSlicesDetail.clear();		mCurrentPlaySlice = "";		mCurrentPlaySliceDetail = "";		isChangeQualityError = false;		heartBeatCount = 1;		usingP2P = false;		playTime = 0;        mAdDelays = "";        mAdCountRemain = 0;        mAdCountTotal = 0;        mAdReqStartTimeStamp = 0;        mAdReqTimes = "";        mAdRsReqTimes = "";        mAdLevel1Error = 0;        mAdLevel2Error = 0;        mIsAdStarted = false;        mVideoConnectDelayTime = 0;        mPlayErrorLevel1 = 0;        mPlayErrorLevel2 = 0;        mSeekCount = 0;        mSeekDuration = "";        mSeekStartTime = 0;		mVVEndError = false;		mOnPaused = false;		mPlayerStarted = false;		mAdBackError = false;		mBeforeDurationAdType =TrackAdType.EMPTY;		mErrorPoint = -1;		mOpenEnhanceTimes = 0;		mOpenEnhanceTimesAuto = 0;		mCloseEnhanceTimes = 0;		mAdReqError = "";		mVideoReqError = "";		mVideo302Delay = 0;		mAd302Delay = -1;		mSlicePlayTime = 0;			isAdChanged = true;		mAutoPlay = "";}	/** 埋第一次缓冲完毕开始播放 	 * @param videoInfo */	public static void onRealVideoFirstLoadEnd(Context context, String vid, VideoUrlInfo videoInfo) {		/*		 * if(!isRealVideoStarted) return;		 */		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;		long currentTime = System.nanoTime() / 1000000;		if (trackLoadingToPlayStart) {			Logger.d(TAG, "trackLoadingToPlayStart true");			trackLoadingToPlayStart = false;			long videoload = 0;			if (mAdEndTime != 0) {				beforeDuration = currentTime - mAdEndTime;				videoload = beforeDuration;			} else {				beforeDuration = currentTime						- loadingToPlayStartTime;				//没有播放广告的情况下不计算获取视屏和广告的时间				videoload = beforeDuration - mGetPlayListDuration						- mGetAdvDuration;			}			mGetAdvDuration = 0;			trackVideoLoadTime(context, videoload, vid, videoInfo);			trackPlayLoading = true;		}		mSlicePlayTime = currentTime;	}	/**	 * 从视频文件开始加载，到播放视频第一帧的时间	 * 	 * @param context	 * @param videoloadTime	 * @param videoInfo 	 */	private static void trackVideoLoadTime(Context context, long videoloadTime,			String vid, VideoUrlInfo videoInfo) {		long currentTime = System.currentTimeMillis();		HashMap<String, String> extend = new HashMap<String, String>();		extend.put("pltype", "videoload");		extend.put("s", videoloadTime + "");		extend.put("st", (currentTime - videoloadTime) + "");		extend.put("et", currentTime + "");		extend.put("hd", getTrackFormat(Profile.getVideoQuality(context)) + "");		if (!TextUtils.isEmpty(vid))			extend.put("vid", vid);		if (videoInfo != null) {			if (!TextUtils.isEmpty(videoInfo.getChannelId()))				extend.put("ct", videoInfo.getChannelId());			if (!TextUtils.isEmpty(videoInfo.getSchannelid()))				extend.put("cs", videoInfo.getSchannelid());		}		AnalyticsWrapper.trackExtendCustomEvent(context,				PlayerStatistics.VIDEO_LOAD, PlayerStatistics.PAGE_NAME, null,				extend);	}		/**	 * 获取用来统计的视频格式	 */	public static int getTrackFormat(int quality) {		switch (quality) {		case Profile.VIDEO_QUALITY_SD:			quality = 0;			break;		case Profile.VIDEO_QUALITY_HD:			quality = 1;			break;		case Profile.VIDEO_QUALITY_HD2:			quality = 2;			break;		case Profile.VIDEO_QUALITY_HD3:			quality = 3;			break;		}		return quality;	}	/** 是否满足统计播放过程中缓冲条件 */	public static void setTrackPlayLoading(boolean isTrack) {		// Logger.i(TAG, "setTrackPlayLoading " + trackPlayLoading);		trackPlayLoading = isTrack;	}		/** 播放过程中，开始缓冲 */	public static void onPlayLoadingStart(long currentPosition) {		if (!isRealVideoStarted)			return;		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;		if (trackPlayLoading) {			playLoadingStartTime = System.nanoTime() / 1000000;			playLoadingPosition = currentPosition;			long adjustTime = System.currentTimeMillis() / 1000;			if (Util.isTimeStampValid())				adjustTime += Util.TIME_STAMP;			playLoadingStartLocalTime += String.valueOf(adjustTime) + "|";			addLoadingEventToSlice();		}	}	private static void addLoadingEventToSlice() {		Logger.d(TAG, "addLoadingEvent");		String slice = mVideoSlices.get(mCurrentPlaySlice);		if (!TextUtils.isEmpty(slice) && slice.endsWith(",")) {			slice += 1;			mVideoSlices.put(mCurrentPlaySlice, slice);		}		if (mVideoSlicesDetail.containsKey(mCurrentPlaySliceDetail))			mVideoSlicesDetail.get(mCurrentPlaySliceDetail).loadingTimes++;	}	/** 播放过程汇中，结束缓冲 */	public static void onPlayLoadingEnd(VideoUrlInfo videoUrlInfo) {		if (!isRealVideoStarted)			return;		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;		if (trackPlayLoading) {			float loadingTime = (System.nanoTime() / 1000000 - playLoadingStartTime);			float loadingPosition = (float) playLoadingPosition / 1000;			if (loadingTime <= 0 || loadingTime > MAX_LOADINGTIME					|| loadingPosition <= 0) {				playLoadingStartTime = 0;				playLoadingPosition = 0;				return;			}			int format = videoUrlInfo != null ? getTrackFormat(videoUrlInfo.getCurrentQuality()) + 1 : 1;			playLoadingEvents += (""					+ String.format(Locale.CHINA, "%.2f", loadingPosition)					+ "," + String.format(Locale.CHINA, "%.2f", loadingTime) + "," + format + "|");			playLoadingStartTime = 0;			playLoadingPosition = 0;		}	}	/** 暂停播放 */	public static void pause() {		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;		Logger.d(TAG,"pause playTime:"+playTime);		if (stageStarted) {			long currentTime = System.nanoTime() / 1000000;			playTime += Math.max(					(currentTime - playStartedTime), 0);			Logger.d(TAG, "pause stageStarted playTime:"+playTime);			if (mAdStartTime != 0) {				mADDuration += currentTime - mAdStartTime;				mAdStartTime = 0;			}			Logger.d(TAG,"pause mCurrentPlaySliceDetail:"+mCurrentPlaySliceDetail+"  mSlicePlayTime:"+mSlicePlayTime);			if (mSlicePlayTime != 0 && mVideoSlicesDetail.containsKey(mCurrentPlaySliceDetail)) {				mVideoSlicesDetail.get(mCurrentPlaySliceDetail).playtime += Math.max(						(currentTime - mSlicePlayTime), 0);				mSlicePlayTime = 0;			}			onSmoothChangeVideoQualityVideoPause();		}		stageStarted = false;	}	public static void pauseForIRVideo(Context context) {		IRVideoWrapper.videoPause(context);	}	public static void playad() {		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;	}	/** 暂停后继续播放 */	public static void play(Boolean isHls, Context context) {		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;		if (!stageStarted) {			stageStarted = true;			playStartedTime = System.nanoTime() / 1000000;// 纳秒转换成毫秒			mSlicePlayTime = playStartedTime;		}		if (!misRequestCalled && !isHls) {			if (mIsChangingLanguage) {				mIsChangingLanguage = false;			}			init();			misRequestCalled = true;			loadingToPlayStartTime = System.nanoTime() / 1000000;		}		if (!mIsPlayStarted) {			trackLoadingToPlayStart = true;			// 播放前中断，重新计算开始时间			if (mOnPaused)			loadingToPlayStartTime = System.nanoTime() / 1000000;			Logger.d(TAG, "play loadingToPlayStartTime:" + loadingToPlayStartTime);		}		onSmoothChangeVideoQualityVideoStart();		IRVideoWrapper.videoPlay(context);	}	/** 当前视频结束播放 */	public static void onPlayEnd(Context context, VideoUrlInfo videoInfo, boolean isFullScreen,			String sdkVer, int testid, int istest) {		if (Profile.from == Profile.PAD_BROWSER				|| Profile.from == Profile.PHONE_BROWSER)			return;		if (trackChangeVideoQualtiy || mIsChangingLanguage) {			return;		}		forceEnd(context, videoInfo, isFullScreen, sdkVer, testid, istest);	}	/**	 * 当前视频结束播放, Track强制结束，一般用于ondestroy() 不考虑高清语言等切换问题	 */	public static void forceEnd(Context context, VideoUrlInfo videoInfo, boolean isFullScreen,								String sdkVer, int testid, int istest) {		if (!mIsPlayStarted) {			clear();			return;		}		mIsPlayStarted = false;		pause();		Logger.d(TAG, "onPlayEnd mADDuration:" + mADDuration + "  playTime:" + playTime);		if (mADDuration > 0) {			playTime = playTime - mADDuration;		}		String duration = String.format(Locale.CHINA, "%.2f",				Math.min(((float) playTime / 1000), 60000));		if (videoInfo == null || videoInfo.getVid() == null				|| TextUtils.getTrimmedLength(videoInfo.getVid()) <= 0) {			return;		}		String vvEndUrl = "&sessionid=" + SessionUnitil.playEvent_session;		String id = videoInfo.getVid();		if (videoInfo.mSource != Source.YOUKU) {			vvEndUrl = vvEndUrl + "&source=" + videoInfo.mSource.ordinal()					+ "&format=" + getVideoFormat(id) + "&width=" + width					+ "&height=" + height;			id = Util.md5(id);		} else if (videoInfo.mSource == Source.BAIDU || videoInfo.mSource == Source.KUAIBO) {			vvEndUrl += "&format=" + Profile.baiduFormat;		}		vvEndUrl = vvEndUrl + "&id=" + id;		String userID = null;		if (MediaPlayerDelegate.mIUserInfo != null) {			userID = MediaPlayerDelegate.mIUserInfo.getUserID();		}		if (userID != null && !userID.equals("")) {			vvEndUrl = vvEndUrl + "&user_id=" + userID;		}		String before = String.format("%.2f", (float) beforeDuration);		String adBefore = "0";		if (mADBeforeDuration != 0)			adBefore = String.format("%.2f", (float) mADBeforeDuration);		vvEndUrl = vvEndUrl + "&type=end&duration=" + duration + "&complete="				+ (isCompleted ? 1 : 0) + "&before_duration=" + before				+ "&adv_before_duration=" + adBefore;		if (videoInfo.playlistId != null && !videoInfo.playlistId.equals("")) {			vvEndUrl = vvEndUrl + "&playlistid=" + videoInfo.playlistId;		}		playLoadingEvents = playLoadingEvents.trim();		if (!playLoadingEvents.equals("")) {			if (playLoadingEvents.endsWith("|")) {				playLoadingEvents = playLoadingEvents.substring(0,						playLoadingEvents.length() - 1);// 去掉"|"			}		} else {			playLoadingEvents = "0,0," + (getTrackFormat(videoInfo.getCurrentQuality()) + 1);		}		if (!TextUtils.isEmpty(playLoadingStartLocalTime)) {			if (playLoadingStartLocalTime.endsWith("|")) {				playLoadingStartLocalTime = playLoadingStartLocalTime						.substring(0, playLoadingStartLocalTime.length() - 1);			}		} else {			playLoadingStartLocalTime = "0";		}				vvEndUrl = vvEndUrl + "&play_load_events=" + playLoadingEvents				+ "&play_rates=" + playLoadingStartLocalTime				+ "&play_sd_times=" + videoQualityToSDTimes				+ "&play_sd_duration=" + videoQualityToSDLoadingTime + ".00"				+ "&play_hd_times=" + videoQualityToHDTimes				+ "&play_hd_duration=" + videoQualityToHDLoadingTime + ".00"				+ "&play_hd2_times=" + videoQualityToHD2Times				+ "&play_hd2_duration=" + videoQualityToHD2LoadingTime + ".00"				//添加平滑切换统计				+ getSmoothSwitchDetails();		String videoTime = String.format(Locale.CHINA, "%.2f",				videoInfo.getDurationMills() / 1000f / 60);			if (videoInfo.mSource == Source.BAIDU				|| videoInfo.mSource == Source.KUAIBO) {			vvEndUrl = vvEndUrl + "&play_types=" + StaticsUtil.PLAY_TYPE_NET					+ "&os=Android" + "&video_time=" + videoTime;		} else {			vvEndUrl = vvEndUrl					+ "&play_types="					+ videoInfo.playType					+ "&os=Android"					+ "&video_format="					+ (getTrackFormat(videoInfo.getCurrentQuality()) + 1);			if (!videoInfo.isHLS)				vvEndUrl += "&video_time=" + videoTime;		}		PlayActionData.Builder builder = new PlayActionData.Builder(id)		.setComplete(isCompleted ? "1" : "0").setPlayEndInfo(adBefore,				before, videoInfo.getDurationMills() / 1000 + "",				duration, playLoadingEvents, playLoadingStartLocalTime,				videoQualityToSDTimes + "",				videoQualityToSDLoadingTime + ".00",				videoQualityToHDTimes + "",				videoQualityToHDLoadingTime + ".00",				videoQualityToHD2Times + "",				videoQualityToHD2LoadingTime + ".00");		String playExperience = generatePlayExperience();		if (!TextUtils.isEmpty(playExperience) && !videoInfo.isCached()) {			vvEndUrl += "&play_experience=" + playExperience;			builder.setPlayExperience(playExperience);		} else if (StaticsUtil.PLAY_TYPE_NET.equals(videoInfo.playType)) {			vvEndUrl += "&play_experience=" + "";		}		String playExperienceDetail = generatePlayExperienceDetail();		Logger.d(TAG, "playExperienceDetail:" + playExperienceDetail);		if (!TextUtils.isEmpty(playExperienceDetail) && !videoInfo.isCached())			vvEndUrl += "&play_experience_detail=" + playExperienceDetail;		if (MediaPlayerConfiguration.getInstance().useP2P()) {			vvEndUrl += "&p2pVersion="					+ P2pManager.getInstance().getP2PVersion();			vvEndUrl += "&isp2p=" + (usingP2P ? 1 : 0);			builder.setP2PVersion(P2pManager.getInstance().getP2PVersion())					.setIsP2P(usingP2P);		}        vvEndUrl += getAdCacheTypes() + getAdDecodings() + getAdTypes() + getAdReqTimes() + getAdRsReqTimes()                + getAdDelays() + getAdLevel1Errors() + getAdLevel2Errors();		if (!TextUtils.isEmpty(videoInfo.token)) {			vvEndUrl += "&ev=" + Profile.ev + "&ctype=" + Profile.ctype					+ "&token=" + videoInfo.token + "&oip=" + videoInfo.oip					+ "&sid=" + videoInfo.sid;			builder.setAntiLink(videoInfo.sid, Profile.ctype + "", Profile.ev,					videoInfo.token, videoInfo.oip);		}		builder.setCurrentFormat(				(getTrackFormat(videoInfo.getCurrentQuality()) + 1) + "")				.setFull(isFullScreen ? "1" : "0")				.setCurrentPlaytime(videoInfo.getProgress() / 1000 + ".00");		if (videoInfo.getLookTen() == 1) {			builder.setFreeTime(600 + "");		}        vvEndUrl = addUrlParam(vvEndUrl, "video_url_req_time", mGetPlayListDuration + ".00");        vvEndUrl = addUrlParam(vvEndUrl, "video_res_req_time", mVideoConnectDelayTime + ".00");        vvEndUrl = addUrlParam(vvEndUrl, "video_1level_err", mPlayErrorLevel1 == 0 ? "" : (mPlayErrorLevel1 + ""));        vvEndUrl = addUrlParam(vvEndUrl, "video_2level_err", mPlayErrorLevel2 == 0 ? "" : (mPlayErrorLevel2 + ""));        vvEndUrl = addUrlParam(vvEndUrl, "seek_count", mSeekCount + "");		vvEndUrl = addUrlParam(vvEndUrl, "seek_duration", TextUtils.isEmpty(mSeekDuration) ? "0" : mSeekDuration.substring(0, mSeekDuration.length() - 1));		vvEndUrl = addUrlParam(vvEndUrl, "ad_jump_times", mAd302Delay + "");		vvEndUrl = addUrlParam(vvEndUrl, "video_jump_times", mVideo302Delay + "");		vvEndUrl = addCommonParam(vvEndUrl, videoInfo);		int errorType = addErrorType(videoInfo);		if (errorType != 0)			vvEndUrl = addUrlParam(vvEndUrl, "error_type", errorType + "");		Logger.d(TAG, "mVVEndError:" + mVVEndError + "  mOnPaused:" + mOnPaused + "  mPlayerStarted:" + mPlayerStarted + "  mAdBackError:" + mAdBackError);		if ((mVVEndError && mOnPaused && !mPlayerStarted) || mAdBackError)			vvEndUrl += "&is_return_from_background=1";		else if (mVVEndError || mAdLevel1Error != 0 || mPlayErrorLevel1 != 0)			vvEndUrl += "&is_return_from_background=0";		vvEndUrl += "&before_duration_adtype=" + mBeforeDurationAdType.ordinal();		if (mErrorPoint != -1)			vvEndUrl += "&exception_message_time=" + mErrorPoint;		int openEnhanceTimes = mOpenEnhanceTimesAuto + mOpenEnhanceTimes;		boolean isOpenEnhance = (openEnhanceTimes > 0 && openEnhanceTimes > mCloseEnhanceTimes);		vvEndUrl = addUrlParam(vvEndUrl, "switch_final", isOpenEnhance ? "1" : "0");		String switch_times = "";		if(mOpenEnhanceTimes > 0 || mCloseEnhanceTimes > 0){			switch_times = mOpenEnhanceTimes + "," + mCloseEnhanceTimes;		}		vvEndUrl += "&autoplay=" + mAutoPlay;		if (testid!=0)			vvEndUrl +="&playsdk_version="+sdkVer+"&testid="+testid+"&istest="+istest;		vvEndUrl = addUrlParam(vvEndUrl, "switch_times", switch_times);		if (!TextUtils.isEmpty(videoInfo.getViddecode()))			builder.setVid(videoInfo.getViddecode());		AnalyticsWrapper.playEnd(context, builder);				Intent intent = new Intent();		intent.setAction("PLAYER_END");		intent.putExtra("VVEndUrl", vvEndUrl);		playerEnd(intent, context, videoInfo.mSource != Source.YOUKU);		misRequestCalled = false;		init();		IRVideoWrapper.videoEnd(context);	}    private static String addUrlParam(String url, String key, String value) {        return url + "&" + key + "=" + value;    }    private static String generatePlayExperience() {		StringBuilder builder = new StringBuilder();		for (Iterator<String> iterator = mVideoSlices.values().iterator(); iterator				.hasNext();) {			String slice = iterator.next();			if (slice.endsWith(","))				slice += 0;			builder.append(slice).append("|");		}		if (builder.toString().endsWith("|")) {			return builder.substring(0, builder.length() - 1);		}		return builder.toString();	}	private static String generatePlayExperienceDetail() {		StringBuilder builder = new StringBuilder();		for (Map.Entry<String, SliceData> entry : mVideoSlicesDetail.entrySet()) {			SliceData slice = entry.getValue();			builder.append(entry.getKey()).append(slice.playtime / 1000).append("_").append(slice.loadingTimes).append("|");		}		if (builder.toString().endsWith("|")) {			return builder.substring(0, builder.length() - 1);		}		return builder.toString();	}	/** 视频缓冲记录 */	public static void setplayCompleted(boolean completed) {		isCompleted = completed;	}	/** 清晰度切换初始化-清空当次，重新开始 */	public static void onChangeVideoQualityStart(Context context) {		//如果当前处于清晰度平滑切换统计，清除当前平滑切换统计值		resetSmoothChangeVideoQuality();		// 切换到标清		if (Profile.getVideoQuality(context) == 2) {			videoQualityToSDTimes++;// 标清转换次数加1		} else if (Profile.getVideoQuality(context) == 1) {// 切换到高清			videoQualityToHDTimes++; // 高清转换次数加1		} else if (Profile.getVideoQuality(context) == 0) {// 切换到超清			videoQualityToHD2Times++;		}		trackChangeVideoQualtiy = true;		changeVideoQualityStartTime = System.nanoTime() / 1000000;// 纳秒转换成毫秒		trackPlayLoading = false;	}	/** 高清标清切换时长统计当次结束 */	public static void onChangVideoQualityEnd(Context context) {		if (trackChangeVideoQualtiy) {			trackChangeVideoQualtiy = false;			trackPlayLoading = true;			if (changeVideoQualityStartTime == 0)				return;			long loadingTime = (System.nanoTime() / 1000000 - changeVideoQualityStartTime);			if (loadingTime < 0)				return;			if (Profile.getVideoQuality(context) == 2) {// 高-标				videoQualityToSDLoadingTime = videoQualityToSDLoadingTime						+ loadingTime;			} else if (Profile.getVideoQuality(context) == 1) {// 标-高				videoQualityToHDLoadingTime = videoQualityToHDLoadingTime						+ loadingTime;			} else if (Profile.getVideoQuality(context) == 0) {// 标-高				videoQualityToHD2LoadingTime = videoQualityToHD2LoadingTime						+ loadingTime;			}		}	}	/** 高清标清切换时遇到网络问题后，删除这次切换统计 */	public static void changeVideoQualityOnError(Context context) {		if (trackChangeVideoQualtiy) {			if (Profile.getVideoQuality(context) == 2) {				videoQualityToSDTimes--;			} else if (Profile.getVideoQuality(context) == 1) {// 切换到高清				videoQualityToHDTimes--;			} else if (Profile.getVideoQuality(context) == 0) {// 切换到超清				videoQualityToHD2Times--;			}			changeVideoQualityStartTime = 0;			trackChangeVideoQualtiy = false;			trackPlayLoading = true;			isChangeQualityError = true;		}	}	/**************************** smooth video quality change start **************************/	private static String mSmoothSwitchDetails = "";	private static int mQulityChangeType = -1;	/** 高清标清平滑切换开始点 */	private static long smoothChangeVideoQualityStartTime;	private static long mSmoothSwitchPauseTime = 0;	private static long mSmoothSwitchPauseDuration = 0;	private static String getSmoothSwitchDetails() {		String str = "";		if (mSmoothSwitchDetails != null && !mSmoothSwitchDetails.isEmpty()) {			str = "&smooth_switch_details=" + mSmoothSwitchDetails;		}		return str;	}	/** 清晰度平滑切换初始化-清空当次，重新开始 */	public static void onSmoothChangeVideoQualityStart(int oldQulity, int newQulity) {		//如果普通清晰度切换正在进行中，去除之前记录的值		if (trackChangeVideoQualtiy) {			trackChangeVideoQualtiy = false;			changeVideoQualityStartTime = 0;			trackPlayLoading = true;			if (oldQulity == 2) {				videoQualityToSDTimes--;			} else if (oldQulity == 1) {// 切换到高清				videoQualityToHDTimes--;			} else if (oldQulity == 0) {// 切换到超清				videoQualityToHD2Times--;			}		}		mQulityChangeType = getQualityChangeType(oldQulity, newQulity);		smoothChangeVideoQualityStartTime = System.nanoTime() / 1000000;// 纳秒转换成毫秒		mSmoothSwitchPauseTime = 0;		mSmoothSwitchPauseDuration = 0;	}	/** 高清标清平滑切换时长统计当次结束 */	public static void onSmoothChangeVideoQualityEnd(boolean isSuccess) {		if (smoothChangeVideoQualityStartTime == 0)			return;		long loadingTime = (System.nanoTime() / 1000000 - smoothChangeVideoQualityStartTime);		if (mSmoothSwitchPauseDuration > 0) {			loadingTime -= mSmoothSwitchPauseDuration;		}		if (loadingTime < 0)			return;		String time = String.format("%.2f", (float) loadingTime);		StringBuilder builder = new StringBuilder();		builder.append(time).append(",").append(isSuccess ? "1" : "0")				.append(",").append(String.valueOf(mQulityChangeType));		if (mSmoothSwitchDetails != null && !mSmoothSwitchDetails.isEmpty()) {			mSmoothSwitchDetails += "|";		}		mSmoothSwitchDetails += builder.toString();		smoothChangeVideoQualityStartTime = 0;		mQulityChangeType = -1;	}	private static int getQualityChangeType(int oldQulity, int newQulity) {		int type = -1;		if (oldQulity == Profile.VIDEO_QUALITY_SD || oldQulity == Profile.VIDEO_QUALITY_AUTO ) {			if (newQulity == Profile.VIDEO_QUALITY_HD) {				type = 1;			} else if (newQulity == Profile.VIDEO_QUALITY_HD2) {				type = 2;			}		} else if (oldQulity == Profile.VIDEO_QUALITY_HD) {			if (newQulity == Profile.VIDEO_QUALITY_SD) {				type = 3;			} else if (newQulity == Profile.VIDEO_QUALITY_HD2) {				type = 4;			}		} else if (oldQulity == Profile.VIDEO_QUALITY_HD2) {			if (newQulity == Profile.VIDEO_QUALITY_SD) {				type = 5;			} else if (newQulity == Profile.VIDEO_QUALITY_HD) {				type = 6;			}		}		return type;	}	private static void onSmoothChangeVideoQualityVideoPause() {		if (smoothChangeVideoQualityStartTime > 0) {			mSmoothSwitchPauseTime = System.nanoTime() / 1000000;		}	}	private static void onSmoothChangeVideoQualityVideoStart() {		if (mSmoothSwitchPauseTime > 0) {			long dur = System.nanoTime() / 1000000 - mSmoothSwitchPauseTime;			if (dur > 0) {				mSmoothSwitchPauseDuration += dur;			}			mSmoothSwitchPauseTime = 0;		}	}	private static void resetSmoothChangeVideoQuality() {		if (smoothChangeVideoQualityStartTime > 0) {			smoothChangeVideoQualityStartTime = 0;			mSmoothSwitchPauseTime = 0;			mSmoothSwitchPauseDuration = 0;			mQulityChangeType = -1;		}	}	/*****************************smooth video quality change end *******************************/	protected static String getVideoid(VideoUrlInfo videoInfo)	{		if (videoInfo.mSource != Source.YOUKU)			return Util.md5(videoInfo.getVid());		return videoInfo.getVid();	}	protected static String getvvBeginUrl(Context context,VideoUrlInfo videoInfo,				String sdkVer, int testid, int istest, PlayVideoInfo playVideoInfo)	{		String vvBeginUrl;		String id = videoInfo.getVid();		if (videoInfo.mSource == Source.BAIDU				|| videoInfo.mSource == Source.KUAIBO) {			vvBeginUrl = "&sessionid=" + SessionUnitil.getPlayVVBeginSession()					+ "&play_types=" + StaticsUtil.PLAY_TYPE_NET					+ "&play_codes=" + PlayCode.PLAY_SUCC + "&format="					+ Profile.baiduFormat + "&type=begin&os=Android";		} else {			vvBeginUrl = "&sessionid=" + SessionUnitil.getPlayVVBeginSession()					+ "&play_types=" + videoInfo.playType + "&play_codes="					+ PlayCode.PLAY_SUCC + "&type=begin&os=Android";		}		String userID = MediaPlayerDelegate.mIUserInfo == null ? ""				: MediaPlayerDelegate.mIUserInfo.getUserID();		if (userID != null && !userID.equals("")) {			vvBeginUrl = vvBeginUrl + "&user_id=" + userID;		}		if (videoInfo.playlistId != null && !videoInfo.playlistId.equals("")) {			vvBeginUrl = vvBeginUrl + "&playlistid=" + videoInfo.playlistId;		}		if (videoInfo.mSource != Source.YOUKU) {			vvBeginUrl = vvBeginUrl + "&source=" + videoInfo.mSource.ordinal()					+ "&format=" + getVideoFormat(id) + "&width=" + width					+ "&height=" + height;			id = Util.md5(id);		} else			vvBeginUrl += "&video_format="					+ (getTrackFormat(videoInfo.getCurrentQuality()) + 1)					+ "&play_decoding="					+ (Profile.useHardwareDecode(context) ? Profile.HARDWARE_DECODE					: Profile.SOFTWARE_DECODE);		vvBeginUrl = vvBeginUrl + "&id=" + id;		if (!TextUtils.isEmpty(videoInfo.token)) {			vvBeginUrl += "&ev=" + Profile.ev + "&ctype=" + Profile.ctype					+ "&token=" + videoInfo.token + "&oip=" + videoInfo.oip					+ "&sid=" + videoInfo.sid;		}		if (testid!=0)			vvBeginUrl +="&playsdk_version="+sdkVer+"&testid="+testid+"&istest="+istest;		if (!TextUtils.isEmpty(mAdReqError))			vvBeginUrl += "&ad_req_error=" + mAdReqError;		if (!TextUtils.isEmpty(mVideoReqError))			vvBeginUrl += "&video_req_error=" + mVideoReqError;		if (isFirstVV)			isFirstVV = false;		else {			if (playVideoInfo != null)				mAutoPlay = playVideoInfo.autoPlay + "";		}		vvBeginUrl += "&autoplay=" + mAutoPlay;		vvBeginUrl = addCommonParam(vvBeginUrl, videoInfo);		return vvBeginUrl;	}	protected static void createPlayAction(Context context, String id,										   VideoUrlInfo videoInfo,									boolean isFullScreen)	{		PlayActionData.Builder builder = new PlayActionData.Builder(id)				.setPlaycode(PlayCode.PLAY_SUCC)				.setPlaytype(videoInfo.playType);		if (!TextUtils.isEmpty(videoInfo.token)) {			builder.setAntiLink(videoInfo.sid, Profile.ctype + "", Profile.ev,					videoInfo.token, videoInfo.oip);		}		builder.setCurrentFormat(				(getTrackFormat(videoInfo.getCurrentQuality()) + 1) + "")				.setFull(isFullScreen ? "1" : "0")				.setContinuePlay(						Profile.getPlayMode(context) == Profile.ALWAYSHOOKUP ? "1"								: "0")				.setVip(MediaPlayerDelegate.mIUserInfo != null ? MediaPlayerDelegate.mIUserInfo						.isVip() : false);		setPlayStartParam(builder,videoInfo);		AnalyticsWrapper.playStart(context, builder);	}	/**	 * @param context	 * @param videoInfo	 * @param isFullScreen	 */	public static void onPlayStart(Context context, VideoUrlInfo videoInfo,			boolean isFullScreen,String sdkVer, int testid, int istest, PlayVideoInfo playVideoInfo) {		if (videoInfo == null || TextUtils.isEmpty(videoInfo.getVid())				|| mIsPlayStarted)			return;		String vvBeginUrl=getvvBeginUrl(context,videoInfo,sdkVer, testid, istest, playVideoInfo);		String id=getVideoid(videoInfo);		createPlayAction(context, id, videoInfo, isFullScreen);		boolean isOpenEnhance = DetailUtil.isUSwitchOpen(context);		vvBeginUrl = addUrlParam(vvBeginUrl, "switch_original", isOpenEnhance ? "1" : "0"); // 播放开始时，U+状态		playerBegin(vvBeginUrl, context, videoInfo.mSource);		mIsPlayStarted = true;		play(false, context);		if (mADDuration == 0) {			IRVideoWrapper.newVideo(context, id,					videoInfo.getDurationMills() / 1000, true);		}	}	private static void setPlayStartParam(PlayActionData.Builder builder,			VideoUrlInfo videoInfo) {		if (builder == null || videoInfo == null)			return;		builder.setStartPlaytime(videoInfo.getProgress() / 1000 + ".00")				.setVideoTime(videoInfo.getDurationMills() / 1000 + "")				.setVideoOwner(videoInfo.getUid())				.setReplay(videoInfo.isReplay())				.setChannelId(videoInfo.getChannelId())				.setSChannelId(videoInfo.getSchannelid())				.setPlaylistId(videoInfo.getPiddecode())				.setPlaylistChannelId(videoInfo.getPlaylistchannelid())				.setSPlaylistChannelId(videoInfo.getSplaylistchannelid())				.setShowId(videoInfo.getSiddecode())				.setShowChannelId(videoInfo.getShowchannelid())				.setSShowChannelId(videoInfo.getSshowchannelid())				.setPayState(videoInfo.getPaystate())				.setPlayState((videoInfo.getLookTen() == 1 ? 2 : 1) + "")				.setCopyright(videoInfo.getCopyright())				.setTailers(videoInfo.getTrailers());		if (videoInfo.getLookTen() == 1) {			builder.setPlayState(2 + "");			builder.setFreeTime(600 + "");		} else			builder.setPlayState(1 + "");		if (!TextUtils.isEmpty(videoInfo.getViddecode()))			builder.setVid(videoInfo.getViddecode());	}		public static void onPlayHlsStart(Context context, String liveId,			String usrId, int isPaid, String sid, String bps, int autoplay,		    int areaCode, int dmaCode, String oip, int ctype,			String ev, String token, boolean isVip, boolean isFullScreen,			String sdkVer, int testid, int istest) {		if (TextUtils.isEmpty(liveId) || mIsPlayStarted)			return;		String vvBeginUrl = null;        String fullScreen = "1";        String vip = "0";		String usrid = (usrId != null && !usrId.equals("")) ? ("&uid=" + usrId)				: "";        fullScreen = isFullScreen ? "1" : "0";        vip = isVip ? "1" : "0";		try {			String rpage = AnalyticsAgent.getLastPageSource();			rpage = (rpage != null && !rpage.equals("")) ? ("&rpage=" + URLEncoder						.encode(rpage, "UTF-8")) : "";			vvBeginUrl = "liveid=" + liveId + usrid + "&pay=" + isPaid					+ "&vvid=" + sid + rpage					+ "&bps=" + bps + "&atp=" + autoplay + "&full=" + fullScreen					+ "&area=" + areaCode + "&dma=" + dmaCode + "&p2p=" + 0					+ "&oip=" + oip + "&ctype=" + ctype + "&ev=" + ev + "&token=" + token                    + "&rate=" + 400 + "&pvid=" + "" + "&vip=" + vip;			if (testid!=0)				vvBeginUrl +="&playsdk_version="+sdkVer+"&testid="+testid+"&istest="+istest;		} catch (UnsupportedEncodingException e) {			Logger.e(TAG, e);		}		playerHlsBegin(vvBeginUrl, context);		IRVideoWrapper.newVideo(context, liveId, 0, true);	}	public static void clear() {		changeVideoQualityStartTime = 0;		trackChangeVideoQualtiy = false;		mIsPlayStarted = false;		misRequestCalled = false;		isRealVideoStarted = false;		init();	}	public static void onError(Context context, String id, String guid,			String playType, String playCode, Source source, int quality,			int progress, boolean isFullScreen, VideoUrlInfo videoInfo, PlayVideoInfo playVideoInfo) {		String tempSessionID = SessionUnitil.getPlayVVBeginSession();		String vvBeginUrl;		if (source == Source.BAIDU || source == Source.KUAIBO) {			vvBeginUrl = "&sessionid=" + tempSessionID + "&play_types="					+ StaticsUtil.PLAY_TYPE_NET + "&play_codes=" + playCode					+ "&type=begin&os=Android";		} else {			vvBeginUrl = "&sessionid=" + tempSessionID + "&play_types="					+ playType + "&play_codes=" + playCode					+ "&type=begin&os=Android";		}				String userID = MediaPlayerDelegate.mIUserInfo == null ? ""				: MediaPlayerDelegate.mIUserInfo.getUserID();		if (userID != null && !userID.equals("")) {			vvBeginUrl = vvBeginUrl + "&user_id=" + userID;		}		if (source != Source.YOUKU) {			// 解决4.4 Attempt to invoke virtual method 问题			try {				vvBeginUrl = vvBeginUrl + "&source=" + source.ordinal()						+ "&format=" + getVideoFormat(id) + "&width=" + width						+ "&height=" + height;				id = Util.md5(id);			} catch (Exception e) {				Logger.d(TAG, "npt:" + e.getMessage());			}		} else			vvBeginUrl += "&video_format="					+ (getTrackFormat(quality) + 1)					+ "&play_decoding="					+ (Profile.useHardwareDecode(context) ? Profile.HARDWARE_DECODE							: Profile.SOFTWARE_DECODE);		vvBeginUrl = vvBeginUrl + "&id=" + id;		PlayActionData.Builder builder = new PlayActionData.Builder(id)				.setPlaycode(playCode).setPlaytype(playType);		builder.setCurrentFormat((getTrackFormat(quality) + 1) + "")				.setFull(isFullScreen ? "1" : "0")				.setContinuePlay(						Profile.getPlayMode(context) == Profile.ALWAYSHOOKUP ? "1"								: "0")				.setStartPlaytime(progress / 1000 + ".00")				.setVip(MediaPlayerDelegate.mIUserInfo != null ? MediaPlayerDelegate.mIUserInfo						.isVip() : false);		if (videoInfo != null && !TextUtils.isEmpty(videoInfo.token)) {			builder.setAntiLink(videoInfo.sid, Profile.ctype + "", Profile.ev,					videoInfo.token, videoInfo.oip);			vvBeginUrl += "&ev=" + Profile.ev + "&ctype=" + Profile.ctype					+ "&token=" + videoInfo.token + "&oip=" + videoInfo.oip					+ "&sid=" + videoInfo.sid;		}		int testid=MediaPlayerConfiguration.getInstance().mTestid;		if (testid!=0)			vvBeginUrl +="&playsdk_version="+MediaPlayerConfiguration.getInstance().getVersionCode()					+"&testid="+testid					+"&istest="+MediaPlayerConfiguration.getInstance().mIstest;		if (!TextUtils.isEmpty(mAdReqError))			vvBeginUrl += "&ad_req_error=" + mAdReqError;		if (!TextUtils.isEmpty(mVideoReqError))			vvBeginUrl += "&video_req_error=" + mVideoReqError;		String autoPlay = "";		if (isFirstVV)			isFirstVV = false;		else {			if (playVideoInfo != null)				autoPlay = playVideoInfo.autoPlay + "";		}		vvBeginUrl += "&autoplay=" + autoPlay;		setPlayStartParam(builder, videoInfo);        vvBeginUrl = addCommonParam(vvBeginUrl, videoInfo);		AnalyticsWrapper.playStart(context, builder);		final String url = URLContainer.getStatVVBegin(vvBeginUrl,				source != Source.YOUKU);		final StatisticsTask statisticsTask = new StatisticsTask(url, context);		statisticsTask.execute();		Logger.d(LogTag.TAG_STATISTIC, "url:" + url);		// mIsPlayStarted = false;		misRequestCalled = false;		IRVideoWrapper.videoEnd(context);	}	/**	 * @return the trackChangeVideoQualtiy	 */	public static boolean isTrackChangeVideoQualtiy() {		return trackChangeVideoQualtiy;	}	/**	 * 发送开始vv	 * 	 * @param VVBeginUrl	 */	public static void playerBegin(String VVBeginUrl, Context context, Source source) {		final String url = URLContainer.getStatVVBegin(				VVBeginUrl, source != Source.YOUKU);		Logger.d(LogTag.TAG_STATISTIC, "url:" + url);		final StatisticsTask statisticsTask = new StatisticsTask(url, context);		statisticsTask.execute();	}	public static void playerHlsBegin(String VVBeginUrl, Context context) {		playTime = 0;		final String url = URLContainer.getHlsStatVVBegin(VVBeginUrl, context);		Logger.d(LogTag.TAG_STATISTIC, "url:" + url);		final StatisticsTask statisticsTask = new StatisticsTask(url, false, context);		statisticsTask.execute();	}	/**	 * 发送结束vv	 * 	 * @param intent	 */	public static void playerEnd(Intent intent, Context context,			boolean isExternalVideo) {		final String url = URLContainer.getStatVVEnd(				intent.getStringExtra("VVEndUrl"), isExternalVideo);		Logger.d(LogTag.TAG_STATISTIC, "url:" + url);		final StatisticsTask statisticsTask = new StatisticsTask(url, context);		statisticsTask.execute();	}	public static void setChangingLanguage(boolean isChange) {		mIsChangingLanguage = isChange;	}	/**	 * 播放请求	 * 	 * @param vid	 *            视频id	 * @param playType	 *            播放类型(net/local/uplocal)	 * @param isLogin	 *            用户的状态（登陆/匿名）	 */	public static void playRequest(Context context, String vid,			String playType, Boolean isLogin) {		if (trackChangeVideoQualtiy) {			return;		}		if (mIsChangingLanguage) {			mIsChangingLanguage = false;			return;		}		SessionUnitil.playEvent_session = SessionUnitil.creatSession();		AnalyticsWrapper.playRequest(context, vid, playType);		init();		trackLoadingToPlayStart = true;		loadingToPlayStartTime = System.nanoTime() / 1000000;		Logger.d(TAG, "playRequest loadingToPlayStartTime:" + loadingToPlayStartTime);		misRequestCalled = true;	}	public static void onMidAdAStart() {		Logger.d(TAG, "mid ad start!");		mAdStartTime = System.nanoTime() / 1000000;		mIsAdStarted = true;	}	public static void onMidAdEnd(){		if (mAdStartTime != 0) {			Logger.d(TAG, "mid ad end!");			mAdEndTime = System.nanoTime() / 1000000;			mADDuration += mAdEndTime - mAdStartTime;			mAdStartTime = 0;			mIsAdStarted = false;		}	}	public static void onAdStart(Context context, MediaPlayerDelegate mediaPlayerDelegate) {        if (mADBeforeDuration == 0) {            if (mediaPlayerDelegate != null                    && mediaPlayerDelegate.videoInfo != null) {                Logger.d(TAG, "Ad Start");                IRVideoWrapper.newVideo(context,                        mediaPlayerDelegate.videoInfo.getVid(),                        mediaPlayerDelegate.videoInfo.getDurationMills() / 1000,                        true);            }        }		Logger.d(TAG, "trackLoadingToPlayStart ---> " + trackLoadingToPlayStart);		if (trackLoadingToPlayStart) {            mAdStartTime = System.nanoTime() / 1000000;            if (mADBeforeDuration == 0) {                mADBeforeDuration = mAdStartTime - loadingToPlayStartTime;                addAdDelays(mADBeforeDuration);            } else {                if (mAdStartTime - mAdEndTime > 0 && !mIsAdStarted) {                    addAdDelays(mAdStartTime - mAdEndTime);                }            }            mIsAdStarted = true;        }	}	/**	 * 从得到广告播放地址，到广告加载完成，播放第一帧广告的时间	 * @param context	 * @param videoInfo 	 */	public static void trackAdLoad(Context context, String vid, VideoUrlInfo videoInfo) {		if (!MediaPlayerConfiguration.getInstance().trackAd())			return;		if (mGetAdvTime != 0) {			long currentTime = System.currentTimeMillis();			long duration = SystemClock.elapsedRealtime() - mGetAdvTime;			mGetAdvTime = 0;			HashMap<String, String> extend = new HashMap<String, String>();			extend.put("pltype", "adload");			extend.put("st", (currentTime - duration) + "");			extend.put("et", currentTime + "");			extend.put("s", duration + "");			if (!TextUtils.isEmpty(vid))				extend.put("vid", vid);			if (videoInfo != null) {				if (!TextUtils.isEmpty(videoInfo.getChannelId()))					extend.put("ct", videoInfo.getChannelId());				if (!TextUtils.isEmpty(videoInfo.getSchannelid()))					extend.put("cs", videoInfo.getSchannelid());			}			AnalyticsWrapper.trackExtendCustomEvent(context,					PlayerStatistics.AD_LOAD, PlayerStatistics.PAGE_NAME, null,					extend);		}	}	public static void onAdEnd() {		if (trackLoadingToPlayStart && mAdStartTime != 0) {			Logger.d(TAG, "Ad end");			mAdEndTime = System.nanoTime() / 1000000;			mADDuration += mAdEndTime - mAdStartTime;			mAdStartTime = 0;			mIsAdStarted = false;		}		isAdChanged = true;	}	public static void onImageAdStart(Context context,			MediaPlayerDelegate mediaPlayerDelegate) {		if (trackLoadingToPlayStart) {			if (mADBeforeDuration == 0) {				mAdStartTime = System.nanoTime() / 1000000;				mADBeforeDuration = mAdStartTime - loadingToPlayStartTime;				Logger.d(TAG,"mAdStartTime - "+loadingToPlayStartTime+" = "+mADBeforeDuration);			}		}	}	public static void onImageAdEnd() {		if (trackLoadingToPlayStart) {			mAdEndTime = System.nanoTime() / 1000000;//			mADDuration = mAdEndTime - mAdStartTime;			// 图片广告是在mediapler start前显示，不需要减去广告时间			mADDuration = 0;            mAdStartTime = 0;		}	}	// TODO 改	private static String getVideoFormat(String path) {		if (!TextUtils.isEmpty(path)) {			int index = path.toLowerCase().lastIndexOf(".");			if (index != -1)				return path.substring(index + 1);		}		return "";	}		/**	 * 从请求广告容量服务器，到返回广告内容的时间	 * @param videoInfo	 */	public static void trackValfLoad(Context context, long adVideoGetTime, String vid,                                     final VideoUrlInfo videoInfo, final VideoAdvInfo videoAdvInfo) {		if (!MediaPlayerConfiguration.getInstance().trackAd())			return;		Track.mGetAdvTime = SystemClock.elapsedRealtime();		if (adVideoGetTime > 0) {			long currentTime = System.currentTimeMillis();			long duration = SystemClock.elapsedRealtime() - adVideoGetTime;			Track.mGetAdvDuration = duration;			HashMap<String, String> extend = new HashMap<String, String>();			extend.put("pltype", "valfload");			extend.put("s", duration + "");			extend.put("st", (currentTime - duration) + "");			extend.put("et", currentTime + "");			extend.put("hd", getTrackFormat(Profile.getVideoQuality(context)) + "");			if (videoInfo != null) {				if (!TextUtils.isEmpty(videoInfo.getChannelId()))					extend.put("ct", videoInfo.getChannelId());				if (!TextUtils.isEmpty(videoInfo.getSchannelid()))					extend.put("cs", videoInfo.getSchannelid());			}			if (!TextUtils.isEmpty(vid))				extend.put("vid", vid);			AnalyticsWrapper.trackExtendCustomEvent(context,					PlayerStatistics.VALF_LOAD, PlayerStatistics.PAGE_NAME,					null, extend);		}	}		/**	 * 从请求视频信息接口，到返回视频文件片地址的时间	 */	public static void trackGetPlayList(Context context, long getPlayListTime, String vid) {        if (getPlayListTime > 0) {            long currentTime = System.currentTimeMillis();            mGetPlayListDuration = SystemClock.elapsedRealtime() - getPlayListTime;            HashMap<String, String> extend = new HashMap<String, String>();            extend.put("pltype", "getplaylist");            extend.put("st", (currentTime - mGetPlayListDuration) + "");            extend.put("et", currentTime + "");            extend.put("s", mGetPlayListDuration + "");            if (!TextUtils.isEmpty(vid))                extend.put("vid", vid);            AnalyticsWrapper.trackExtendCustomEvent(context,                    PlayerStatistics.GET_PLAYLIST, PlayerStatistics.PAGE_NAME,                    null, extend);        }    }	/**	 * 播放心跳统计	 * 	 * @param context	 * @param videoInfo	 */	public static void trackPlayHeart(Context context, VideoUrlInfo videoInfo,			boolean isFullScreen) {		if (context == null || videoInfo == null)			return;		String userid = MediaPlayerDelegate.mIUserInfo == null ? null				: MediaPlayerDelegate.mIUserInfo.getUserID();		PlayActionData.Builder builder = new PlayActionData.Builder(				Track.getAnalyticsVid(videoInfo));		builder.setCurrentFormat(				(getTrackFormat(videoInfo.getCurrentQuality()) + 1) + "")				.setFull(isFullScreen ? "1" : "0")				.setCurrentPlaytime(videoInfo.getProgress() / 1000 + ".00");		if (!TextUtils.isEmpty(videoInfo.token))			builder.setAntiLink(videoInfo.sid, Profile.ctype + "", Profile.ev,					videoInfo.token, videoInfo.oip);		AnalyticsWrapper.playHeart(context, builder, userid);	}		public static void trackPlayHeartTwentyInterval(Context context,			VideoUrlInfo videoInfo, boolean isFullScreen) {		if (context == null || videoInfo == null)			return;		String vvPlayHeart;		final String url;		long localplayTime = 0;        String fullScreen = "1";		String userID = MediaPlayerDelegate.mIUserInfo == null ? null				: MediaPlayerDelegate.mIUserInfo.getUserID();		userID = (userID != null && !userID.equals("")) ? ("&uid=" + userID)				: "";        fullScreen = isFullScreen ? "1" : "0";		if (stageStarted == true) {			localplayTime = System.nanoTime() / 1000000 - playStartedTime					+ playTime;		} else if (stageStarted == false) {			localplayTime = playTime;		}		vvPlayHeart = "liveid=" + videoInfo.getVid()  + userID				+ "&vvid=" + videoInfo.sid + "&full=" + fullScreen +"&p2p=" + 0				+ "&sn=" + heartBeatCount + "&pt=" + localplayTime / 1000F				+ "&hi=" + twentyInterval + "&ctype=" + Profile.ctypeHLS				+ "&r=" + Util.computeSignature(videoInfo.sid + videoInfo.getVid() + 0						+ (localplayTime / 1000F) + heartBeatCount);		url = URLContainer.getHlsVVPlayHeart(vvPlayHeart, context);		Logger.d(LogTag.TAG_STATISTIC, "url:" + url);		final StatisticsTask statisticsTask = new StatisticsTask(url, false,				context);		statisticsTask.execute();		heartBeatCount++;	}	public static void trackUserExperience(Context context,			VideoUrlInfo videoInfo, float totalSecond, int count) {		if (context == null || videoInfo == null || videoInfo.mLiveInfo == null)			return;		String vvUserExperience = null;        String vip = "0";		final String url;		String userID = MediaPlayerDelegate.mIUserInfo == null ? null				: MediaPlayerDelegate.mIUserInfo.getUserID();		userID = (userID != null && !userID.equals("")) ? ("&uid=" + userID)				: "";        vip = videoInfo.mLiveInfo.isVip ? "1" : "0";        try {			String rpage = AnalyticsAgent.getLastPageSource();			rpage = (rpage != null && !rpage.equals("")) ? ("&rpage=" + URLEncoder						.encode(rpage, "UTF-8")) : "";			vvUserExperience = "liveid=" + videoInfo.getVid() 					+ userID + "&pay=" + videoInfo.mLiveInfo.isPaid + rpage					+ "&vvid=" + videoInfo.sid + "&ctype=" + Profile.ctypeHLS + "&t=" + "bufferload" 					+ "&s=" + totalSecond + "&c=" + count + "&bps=" + videoInfo.bps 					+ "&area=" + videoInfo.mLiveInfo.areaCode 					+ "&dma=" + videoInfo.mLiveInfo.dmaCode + "&p2p=" + 0                    + "&rate=" + 400 + "&pvid=" + "" + "&vip=" + vip;		} catch (UnsupportedEncodingException e) {			Logger.e(TAG, e);		}		url = URLContainer.getUserExperience(vvUserExperience);		Logger.d(LogTag.TAG_STATISTIC, "url:" + url);		final StatisticsTask statisticsTask = new StatisticsTask(url, false,				context);		statisticsTask.execute();	}	public static void onVideoIndexUpdate(Context context, int currentIndex,			int ip, int format) {		String strIp = PlayerUtil.intToIP(ip);		int quality = getTrackFormat(format) + 1;		String key = quality + "," + strIp + "_" + currentIndex;		mCurrentPlaySlice = key;		if (!mVideoSlices.containsKey(key)) {			mVideoSlices.put(key, key + ",");		}		long currentTime = System.nanoTime() / 1000000;		if (mSlicePlayTime != 0 && mVideoSlicesDetail.containsKey(mCurrentPlaySliceDetail)) {			mVideoSlicesDetail.get(mCurrentPlaySliceDetail).playtime += Math.max(					(currentTime - mSlicePlayTime), 0);	}		Logger.d(TAG,"onVideoIndexUpdate mCurrentPlaySliceDetail:"+mCurrentPlaySliceDetail+"  mVideoSlicesDetail.containsKey(mCurrentPlaySliceDetail):"+mVideoSlicesDetail.containsKey(mCurrentPlaySliceDetail));		mSlicePlayTime = currentTime;		String keyDetail = strIp + "_" + currentIndex + "_" + quality + "_";		mCurrentPlaySliceDetail = keyDetail;		if (!mVideoSlicesDetail.containsKey(keyDetail)){			mVideoSlicesDetail.put(keyDetail, new SliceData());		}	}	public static void trackP2PError(String videoId, String p2pError) {		HashMap<String, String> extend = new HashMap<String, String>();		extend.put("vid", videoId);		extend.put("failP2p", p2pError + "");		extend.put("p2pVersion", P2pManager.getInstance().getP2PVersion());		AnalyticsWrapper.trackExtendCustomEvent(				com.baseproject.utils.Profile.mContext, "播放器未采用p2p", "p2p",				null, extend);	}		/**	 * 发送硬解错误	 */	public static void sendHwError(){		DisposableHttpTask task = new DisposableHttpTask(				URLContainer.getHwErrorUrl());		task.setRequestMethod(DisposableHttpTask.METHOD_POST);		task.start();	}	public static void setP2P(boolean useP2p) {		if (usingP2P)			return;		usingP2P = useP2p;	}		/**	 * 获取统计sdk使用的vid，有数字id优先用数字id	 * @param videoInfo	 * @return	 */	public static String getAnalyticsVid(VideoUrlInfo videoInfo) {		if (videoInfo == null)			return "";		String vid = videoInfo.getViddecode();		if (TextUtils.isEmpty(vid))			return videoInfo.getVid();		else			return vid;	}	public static void setTrackChangeVideoQualtiy(boolean track) {		trackChangeVideoQualtiy = track;	}    public static void onAdReqStart() {        mAdReqStartTimeStamp = SystemClock.elapsedRealtime();    }	public static void onAdReqEnd(final VideoAdvInfo videoAdvInfo) {		if (mAdReqStartTimeStamp > 0) {			long dur = SystemClock.elapsedRealtime() - mAdReqStartTimeStamp;			addAdReqTimes(dur);		}		if (AdUtil.isAdvVideoType(videoAdvInfo)) {			if (videoAdvInfo != null && videoAdvInfo.VAL != null) {				mAdCountTotal = videoAdvInfo.VAL.size();				mAdCountRemain = mAdCountTotal;				if (!videoAdvInfo.VAL.isEmpty()) {					mBeforeDurationAdType = TrackAdType.VIDEO;					for (AdvInfo advInfo : videoAdvInfo.VAL) {						if (AdUtil.isTrueViewAd(advInfo)) {							mBeforeDurationAdType = TrackAdType.TRUE_VIEW;							break;						}					}				}			}		} else			mBeforeDurationAdType = TrackAdType.PICTURE;	}    private static void addAdReqTimes(long t) {        String time;        if (t > 0) {            time = String.format("%.2f", (float) t);        } else {            time = DEFAULT_AD_REQUIRE_TIME;        }        if (mAdReqTimes.isEmpty()) {            mAdReqTimes = time;        } else {            //目前仅支持前贴            //mAdReqTimes += "|" + time;        }    }    private static String getAdReqTimes() {        String str;        if (!mAdReqTimes.isEmpty()) {            str = "&ad_url_req_times=" + mAdReqTimes;        } else {            str = "&ad_url_req_times=" + DEFAULT_AD_REQUIRE_TIME;        }        return str;    }    public static void addAdRsReqTimes(long t, boolean isPreAd) {        if (!isPreAd || !isAdChanged) {            return;        }		isAdChanged = false;        String time = String.format("%.2f", (float) t);        if (mAdRsReqTimes.isEmpty()) {            mAdRsReqTimes += time;        } else {            mAdRsReqTimes += "," + time;        }    }    private static String getAdRsReqTimes() {        String str;        if (!mAdRsReqTimes.isEmpty()) {            if (mAdCountRemain > 0) {                for (int i = 0; i < mAdCountRemain; i++) {                    mAdRsReqTimes += "," + DEFAULT_AD_RS_REQUIRE_TIME;                }            }            str = "&ad_res_req_times=" + mAdRsReqTimes;        } else {            str = "&ad_res_req_times=" + DEFAULT_AD_RS_REQUIRE_TIME;        }        return str;    }    private static String getAdCacheTypes() {        return "&ad_cache_types=net";    }    private static String getAdDecodings() {        return "&ad_decodings=1";    }    private static String getAdTypes() {        return "&ad_types=1";    }    private static void addAdDelays(long t) {        String time = String.format("%.2f", (float) t);        if (mAdDelays.isEmpty()) {            mAdDelays += time;        } else {            mAdDelays += "," + time;        }        if (mAdCountRemain > 0) {            mAdCountRemain--;        }    }    private static String getAdDelays() {        if (mAdCountRemain > 0) {            for (int i = 0; i < mAdCountRemain; i++) {                if (mAdDelays.isEmpty()) {                    mAdDelays += DEFAULT_AD_DELAY;                } else {                    mAdDelays += "," + DEFAULT_AD_DELAY;                }            }        }        if (mAdDelays.isEmpty()) {            return "&ad_delays=" + DEFAULT_AD_DELAY;        } else {            return "&ad_delays=" + mAdDelays;        }    }    public static void addAdLevelErrors(int level1Error, int level2Error, boolean isPreAd) {		if (mOnPaused)			mAdBackError = true;		if (isPreAd) {            mAdEndTime = 0;            mAdLevel1Error = level1Error;            mAdLevel2Error = level2Error;        }    }    private static String getAdLevel1Errors() {        String str = "&ad_1level_errs=";        if (mAdCountTotal <= 0) {            return str;        }        int count = mAdCountTotal - mAdCountRemain - 1;        if (count < 0) {            return str + mAdLevel1Error;        }        for (int i = 0; i < mAdCountTotal; i++) {            if (i > 0) {                str += ",";            }            if (i == count) {                str += mAdLevel1Error;                return str;            } else {                str += DEFAULT_PLAY_ERROR;            }        }        return str;    }    private static String getAdLevel2Errors() {        String str = "&ad_2level_errs=";        if (mAdCountTotal <= 0) {            return str;        }        int count = mAdCountTotal - mAdCountRemain - 1;        if (count < 0) {            return str + mAdLevel2Error;        }        for (int i = 0; i < mAdCountTotal; i++) {            if (i > 0) {                str += ",";            }            if (i == count) {                str += mAdLevel2Error;                return str;            } else {                str += DEFAULT_PLAY_ERROR;            }        }        return str;    }    public static void setVideoConnectDelayTime(int time){        if (mVideoConnectDelayTime == 0)            mVideoConnectDelayTime = time;    }    public static void onSeek() {        mSeekStartTime = SystemClock.elapsedRealtime();    }    public static void onSeekComplete() {        if (mSeekStartTime != 0) {			mSeekDuration += (SystemClock.elapsedRealtime() - mSeekStartTime) + ".00,";            mSeekStartTime = 0;            ++mSeekCount;        }    }    public static void onPlayError(int errorLevel1, int errorLevel2, int currentPosition){        mPlayErrorLevel1 = errorLevel1;        mPlayErrorLevel2 = errorLevel2;		mErrorPoint = currentPosition / 1000;	}	/**	 * begin和end都需要发送的字段	 * @param url	 * @param videoInfo	 * @return	 */	private static String addCommonParam(String url, VideoUrlInfo videoInfo) {		url = addDNS(url);		url = addIP(url);		url = addCodingFormat(url, videoInfo);		url = addPhoneStream(url, videoInfo);		if (Profile.PLANTFORM == Plantform.TUDOU) {			int isMember = MediaPlayerDelegate.mIUserInfo == null ? 0					: (MediaPlayerDelegate.mIUserInfo.isVip() ? 1 : 0);			url = url + "&isMember=" + isMember;			int isFeeVideo = 0;			if (videoInfo != null && videoInfo.isFeeVideo())				isFeeVideo = 1;			url = url + "&isFeeVideo=" + isFeeVideo;			int isFeeView = 0;			if (videoInfo != null && videoInfo.isFeeView())				isFeeView = 1;			url = url + "&isFeeView=" + isFeeView;		}		return url;	}	private static String addPhoneStream(String url, VideoUrlInfo videoInfo) {		String isPhoneStream = videoInfo != null && videoInfo.isVerticalVideo() ? "1" : "0";		return addUrlParam(url, "is_phone_stream", isPhoneStream);	}	private static String addCodingFormat(String url, VideoUrlInfo videoInfo) {		int codingFormat = videoInfo != null && videoInfo.playH265Segs() ? 1 : 0;		return addUrlParam(url, "video_coding_format", codingFormat + "");	}    private static String addIP(String url) {        return addUrlParam(url, "intrIP", PlayerUtil.getIp());    }    private static String addDNS(String url) {        List<String> dns = PlayerUtil.getDNS();        if (dns != null && !dns.isEmpty()) {            String result = "";            for (String addr : dns) {                result += addr + "|";            }            result = result.substring(0, result.length() - 1);            return addUrlParam(url, "dns", result);        }        return url;    }	public static void setVVEndError(boolean error) {		mVVEndError = error;	}	public static void setPlayerStarted(boolean started) {		mPlayerStarted = started;		if (started)			setOnPaused(false);	}	public static void setOnPaused(boolean onPaused) {		mOnPaused = onPaused;	}	public static void onVideo302Delay(int time) {		if (mVideo302Delay == 0)			mVideo302Delay = time;	}	public static void onAd302Delay(int time) {		if (mAd302Delay == -1 && !isRealVideoStarted)			mAd302Delay = time;	}	public enum TrackAdType {		VIDEO, PICTURE, EMPTY, OTHERS, TRUE_VIEW	}	public static void changeEnhanceSwitchOpenTimes(){		mOpenEnhanceTimes ++;	};	public static void changeEnhanceSwitchAutoOpenTimes(){		mOpenEnhanceTimesAuto ++;	};	public static void changeEnhanceSwitchCloseTimes(){		mCloseEnhanceTimes ++;	}	private static int addErrorType(VideoUrlInfo videoUrlInfo) {		int errorType = 0;		if (mPlayErrorLevel1 != 0) {			if (!videoUrlInfo.isCached()) {				if (mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_VIDEO_TRACK_LAGGING || mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_BAD_INTERLEAVING						|| mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_NOT_SEEKABLE || mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_PLAYERROR)					errorType = 1;				else if (mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_PREPARE_ERROR)					errorType = 2;				else {					if (Util.hasInternet())						errorType = 4;					else						errorType = 3;				}			} else {				if (mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_DATA_SOURCE_ERROR || mPlayErrorLevel1 == MPPErrorCode.MEDIA_INFO_PREPARE_ERROR)					errorType = 2;				else					errorType = 1;			}		}		return errorType;	}	public static void setAdReqError(String code) {		if (TextUtils.isEmpty(mAdReqError))			mAdReqError = code;    }	public static void setVideoReqError(String code){		mVideoReqError = code;    }	public static void setFirstVV() {		isFirstVV = true;	}	private static class SliceData {		public long playtime;		public int loadingTimes;	}}